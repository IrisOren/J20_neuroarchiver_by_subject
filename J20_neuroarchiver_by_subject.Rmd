---
title: "J20 by subject analysis"
author: "Iris Oren"
date: "14/06/2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r initialisation, include=TRUE, echo = FALSE}
AnimalIDCurrent<-"JF110"
DataFile<-"~/Dropbox/ANALYSIS/J20_EEG_Manuscript/Output/SCPPDataframeAll.csv" #Ouput of J20_EEG_Manuscript.Rmd
SpikesPCAFilename<-"~/Dropbox/ANALYSIS/Neuroarchiver/J20EEG/SpikeDetectionMatthias/JF110/DataJF110/E6_detected_spikes_clustered.txt"
ClustersToInclude<-c(0,4)  #Specify which clusters to include based on jupyter notebook classifiy_spikes_and_saveCalcClusters.ipynb
TimeZone<-"Europe/london"


#Load packages
library(lubridate)
library(dplyr)
library(lazyeval) #Needed for using ggplot2 library
library(ggplot2)
library(grid)

#Import data and filter for animal
Dataframe<-read.csv(DataFile)
Dataframe<-filter(Dataframe, AnimalIDVariable==AnimalIDCurrent)
```

#`r AnimalIDCurrent`

###Dataloss over time
```{r DatalossOverTime, include=TRUE, echo = FALSE}
DataLossOverTime<-ggplot(Dataframe, aes(x=strptime(TimeOfDay, format = "%Y-%m-%d %H:%M:%S"), y=Loss)) + xlab("Date") + ylab("Loss")
DataLossOverTime<-DataLossOverTime + geom_point() +
  geom_hline(yintercept = 20)
DataLossOverTime
```
```{r LossQuantilesECDF, include = TRUE}
#OPTIONAL: manually select dataframe rows when transmitter was on for quantifying the loss of the transmitter. This is determined from the Loss vs Time plot
TransmitterOffTime<-Dataframe$InitialisedTime[1]
TransmitterOnTime<-Dataframe$InitialisedTime[2]
DataframeOn<-filter(Dataframe, InitialisedTime<TransmitterOffTime | InitialisedTime>TransmitterOnTime)

#OR
#DataframeOn<-Dataframe
############

LossECDF<-ecdf(DataframeOn$Loss)
plot(LossECDF, xlab="Loss %", main="ECDF Loss")
QuantileDivisions<-seq(0, 1, 0.05)
LossQuantiles<-quantile(Dataframe$Loss, QuantileDivisions)
LossIntervalIndex<-which(LossQuantiles>20)[1]  #Index for quantile where loss exceeds 20%
LossIntervalPercentage<-LossQuantiles[LossIntervalIndex]

```

For periods when the transmitter was on, `r LossIntervalPercentage` intervals had loss <20%


###Filter out loss intervals
This accounts for when transmitter was switched off/lossy and artifacts
```{r FilterOutLoss, include = TRUE, echo = FALSE}
LossThresholdForFiltering=20
DataframeNoLoss<-filter(Dataframe, Loss<LossThresholdForFiltering)
DataframeNoLoss<-filter(DataframeNoLoss, Delta<1000)
```

###Spike count over time

```{r SpikeCountOverTimeControl, include=TRUE, echo = FALSE}
SpikeCountOverTime<-ggplot(DataframeNoLoss, aes(x=strptime(TimeOfDay, format = "%Y-%m-%d %H:%M:%S"), y=SpikeCount, colour=Treatment)) + xlab("Date") + ylab("Spikes/8s")
SpikeCountOverTime<-SpikeCountOverTime + geom_point()
SpikeCountOverTime
```

###Polar histogram of IIS from neuroarchiver in control condition
```{r PolarHistogram, include=TRUE, echo = FALSE}
DataframeControl<-filter(DataframeNoLoss, Treatment=="Control")
#Manually make new dataframe for histogram plotting. Intialise
SpikeCountHistDF<-data.frame(SpikeCount=double(), HourBin=integer())
#First get the hour of each interval in the dataframe

DataframeControl$TimeOfDay<-strptime(DataframeControl$TimeOfDay, "%Y-%m-%d %H:%M:%S")

DataframeControl$HourOfEvent <- hour(DataframeControl$TimeOfDay)

DataframeSelect<-select(DataframeControl, SpikeCount, HourOfEvent)
for(Hour in 0:23){
  DataframeTemp<-filter(DataframeSelect, HourOfEvent==Hour)
  TotalSpikeCount<-sum(DataframeTemp$SpikeCount)
  Total8sIntervals<-nrow(DataframeTemp)
  TempDF<-data.frame(SpikeCount=TotalSpikeCount/Total8sIntervals*8, HourBin=Hour+0.5)
  SpikeCountHistDF<-rbind(SpikeCountHistDF, TempDF)
}

SpikeCountHistDF$Light<-SpikeCountHistDF$HourBin %in% seq(7.5, 18.5)

SpikeCountHist<-ggplot(SpikeCountHistDF, aes(x=HourBin, y=SpikeCount, fill=Light)) + geom_bar(stat = "identity")
SpikeCountHist <- SpikeCountHist +
            xlab("Hour") +
            ylab("Spikes per second") +
            scale_x_continuous(limits = c(0,24), expand = c(0,0), breaks = seq(0, 23, 2)) +
            scale_fill_grey(labels=c("Off", "On")) +
            coord_polar(start = 0) 
SpikeCountHist
```

###Polar plotting of spikes identified by PCA analysis

Here, we use the output from the jupyter notebook for plotting circular plots and calculating phase coupling. This analysis does not take into account the length of the recording
```{r PolarPCAHist, include=TRUE, echo=FALSE}
SpikesPCA<-read.csv(SpikesPCAFilename, header=FALSE, sep=" ")
sps=512
names(SpikesPCA)[1]<-"SampleNumber"
names(SpikesPCA)[2]<-"Cluster"
SpikesPCA$Seconds<-(SpikesPCA$SampleNumber)/sps

#Initialise recording time from start of first data file in processor output file
SpikesPCA$Initialised<-SpikesPCA$Seconds+Dataframe$InitialisedTime[1]

#Convert to time of day and hour
SpikesPCA$TimeOfDay<-as.POSIXct(SpikesPCA$Initialised, tz=TimeZone, origin="1970-01-01")
SpikesPCA$HourOfEvent <- hour(SpikesPCA$TimeOfDay)

#Select clusters of interest
SpikesPCA<-SpikesPCA[which(SpikesPCA$Cluster %in% ClustersToInclude),]

#Add variable for light
SpikesPCA$Light <- SpikesPCA$HourOfEvent %in% seq(7,18)

#Shift hour by 0.5
SpikesPCA$HourOfEventShifted<-SpikesPCA$HourOfEvent+0.5

#Plot
fontsize=12

SpikesPCAHist <- ggplot(SpikesPCA,
                        aes(x = HourOfEventShifted, fill = Light)) +
  geom_histogram(breaks = seq(0,   24), binwidth = 2, colour = "grey") + 
  coord_polar(start = 0) + 
  theme_minimal() + 
  scale_fill_grey(labels=c("Off", "On")) + 
  ylab("Count") + 
  ggtitle("IIS by Time of day") + 
  theme(plot.title = element_text (size = fontsize))+
  theme(axis.title.y=element_text (size = fontsize))+
  theme(axis.text.y =element_text (size = fontsize))+
  theme(axis.text.x =element_text (size = fontsize))+
  scale_x_continuous("", limits = c(0, 24), breaks = seq(0, 24), labels = seq(0,24))

SpikesPCAHist

```

###Theta/delta and spikes
For animals with cerebellar reference, we can relate the theta/delta ratio to spikes. Set include=TRUE for animals with cerebellar reference, else include = FALSE.
```{r ThetaOverDeltaRaw, include=FALSE, echo=FALSE}


```